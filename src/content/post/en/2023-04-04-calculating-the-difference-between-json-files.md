---
title: Calculating the difference between JSON files.
slug: calculating-the-difference-between-json-files
publishDate: 2023-04-04T12:25:29.000Z
date_updated: 2023-04-04T12:25:30.000Z
draft: true
excerpt: There are presented methods of finding lacking translations in json files with dictionaries.
---

In this article, we will show how to write a function to determine the difference between two JSON files.

From an educational point of view, this is an excellent example of using recursive functions. From a practical perspective, it is a useful tool for working with translations.

We will be using the script from the command line.

```
node json-diff.js src/locales/en_old.json src/locales/en.json
```

After this command, we can expect that files will be read and all the keys that appear in the first file but are not in the second file will be printed to the standard output.

We will now show the source code of the json-diff.js file.

We will start by checking if the files indicated as arguments exist:

```
const fs = require('fs')

const pathBase = `${process.cwd()}/${process.argv[2]}`;
const pathComp = `${process.cwd()}/${process.argv[3]}`;

if(!fs.existsSync(pathBase)) {
  console.error(`File ${pathBase} not existst`);
  process.exit()
}

if(!fs.existsSync(pathComp)) {
  console.error(`File ${pathComp} not existst`);
  process.exit()
}
```

Then we read the contents of these files and convert JSON to objects.

```
const base = JSON.parse(fs.readFileSync(pathBase).toString());
const comp = JSON.parse(fs.readFileSync(pathComp).toString());
```

Now we write a function for finding differences.

```
function getDiff(a, b) {
  const res = {};

  for (let key in a) {
    if(a.hasOwnProperty(key)) {
      if(!b.hasOwnProperty(key)) {
        res[key] = a[key]
      } else {
        if (typeof a[key] === 'object') {
          res[key] = getDiff(a[key], b[key])
        }
      }
      if(res[key] && !Object.keys(res[key]).length) {
        delete res[key];
      }
    }
  }

  return res;
}
```

Her task is to take a pair of objects and traverse through the keys of the first (base) one. If the second object (subtracted) does not have it, then that key should be added to the result.

Otherwise, it should be checked whether the type is not an object. In this case, it may be necessary to perform a check inside this key.

Here we have a key line - using the getDiff function within itself.

In the end, we delete the keys for which the value is an empty object.

The last line of the program is to display the results on the screen.

```
process.stdout.write(JSON.stringify(getDiff(base, comp)))
```

This program does not support arrays. They are not necessary for translation files. If you want to read about more advanced methods of comparing JSON files, a good starting point is a thread on stack overflow.

Let's see now how the program works in practice. On translation files. The first file is prepared manually and covers all translations in the en\_old.json application, the second one is generated by i18next and is called en.json. The problem is that i18next did not detect all translations.

At first, I did the work manually. I sorted both files on the codeshack.io/json-sorter website.

Then, on the diffchecker website, I identified the differences between...

I have now created a file with missing translations.

```
node ../DevTools/json-diff.js src/locales/en_old.json src/locales/en.json > src/locales/en-codes.json
```

The file displayed and formatted by jq looks like this:

We see that it contains all the missing keys.

When importing files with translations, we can use the deepmerge package. The i18n configuration file could look like this, for example:

```
import Vue from 'vue'
import VueI18n from 'vue-i18n'
import deepmerge from 'deepmerge'

import en from 'vuetify/lib/locale/en'
import pl from 'vuetify/lib/locale/pl'

Vue.use(VueI18n);

const messages = {
  en: deepmerge(
    require('@/locales/en-codes.json'),
    require('@/locales/en.json'),
    {$vuetify: en}
  ),
  pl: deepmerge(
    require('@/locales/pl-codes.json'),
    require('@/locales/pl.json'),
    {$vuetify: pl}
  ),
};

export default new VueI18n({
  locale: process.env.VUE_APP_I18N_LOCALE || 'en',
  fallbackLocale: process.env.VUE_APP_I18N_FALLBACK_LOCALE || 'en',
  messages,
})

export const languages = [
  { text: 'lang.pl', value: 'pl' },
  { text: 'lang.en', value: 'en' },
];
```

If you would like to share your experiences related to automation of translation work, feel free to comment. I would be interested in learning about the tools you use and whether you sometimes write your own auxiliary scripts, or recommend any set of tools.
